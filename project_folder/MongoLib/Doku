Zur Einrichtung mit QtCreator:
1. kurz auf Strg+B drücken
2. Dependency für die Mongolib.dll anfügen(Rechtsklick auf Projekt-> Externe Bibliothek -> Wizard folgen(Dynamische Bibliothek) -> MongoLib.a anwählen)
3. mongolib.h einbinden
Zur Verwendung:
namespace für alles ist "Mongo"
Man braucht eigentlich nur MngThManager, der regelt alles. und die Klassen aus DataHansz fürs aus und einlesen
Die Typen Safe... sind Aliasse für std::shared_ptr<...>, heißt, die löschen sich automatisch, mit [name]->[methode] ganz normal drauf zugreifen

MngThManager:
public:
MngThManager(const QString &stdDir = QDir::tempPath(), quint16 listenPort = 0, QObject *parent = nullptr)
Konstruktor. In stdDir werden die Dateien gespeichert, 
auf listenPort wird auf eingehende Verbindungen gewartet, wenn nichts angegeben ist, wird ein beliebiger Port gewählt, kann später abgerufen werden
und Argument drei ist standard für alle QObjects

~MngThManager()
Destruktor. Fertig.

void createConnection(const QHostAddress &addr, quint16 port = 0)
Erstellt eine Verbindung zu genannter Adresse am Port port. wenn nichts übergeben wird, isses ein random port

void closeConnection()
Schließt eine bestehende Verbindung sauber ab, wird automatisch im Destruktor von MngThManager aufgerufen

bool sendInstruction(quint32 instr, quint32 toPrgm, quint32 args, const QByteArray &content = QByteArray())
instr ist der Befehlscode der Ausgeführt werden soll. Aufzufinden in der enum Instructions in mongolib_global.h
toPrgm ist der Code des Zielprogrammes, null ist für unser Programm reserviert
args ist für argumente zum Befehl als binäre Flags z.B.
content ist der eigentliche Inhalt des Befehls, in Form eines QByteArray.
gibt true bei erfolgreicher und false bei fehlgeschlagener Übertragung zurück

bool sendFile(QFile &file, quint64 filetype);
übergträgt die Datei file auf die andere Seite. true=success, false=failure
filetype ist pro forma fürs programm

